// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: address.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkAddressExist = `-- name: CheckAddressExist :one
SELECT EXISTS (SELECT 1 FROM user_address WHERE user_id = $1)
`

func (q *Queries) CheckAddressExist(ctx context.Context, userID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAddressExist, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createUserAddress = `-- name: CreateUserAddress :one
INSERT INTO user_address (
    user_id, country, city, street_address, postal_code, created_at, updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    NOW(),
    NOW()
)
RETURNING user_id, country, city, street_address, postal_code, created_at, updated_at
`

type CreateUserAddressParams struct {
	UserID        uuid.UUID
	Country       string
	City          string
	StreetAddress string
	PostalCode    sql.NullString
}

func (q *Queries) CreateUserAddress(ctx context.Context, arg CreateUserAddressParams) (UserAddress, error) {
	row := q.db.QueryRowContext(ctx, createUserAddress,
		arg.UserID,
		arg.Country,
		arg.City,
		arg.StreetAddress,
		arg.PostalCode,
	)
	var i UserAddress
	err := row.Scan(
		&i.UserID,
		&i.Country,
		&i.City,
		&i.StreetAddress,
		&i.PostalCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAddress = `-- name: GetAddress :one
SELECT user_id, country, city, street_address, postal_code, created_at, updated_at FROM user_address
WHERE user_id = $1
`

func (q *Queries) GetAddress(ctx context.Context, userID uuid.UUID) (UserAddress, error) {
	row := q.db.QueryRowContext(ctx, getAddress, userID)
	var i UserAddress
	err := row.Scan(
		&i.UserID,
		&i.Country,
		&i.City,
		&i.StreetAddress,
		&i.PostalCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserWithAddress = `-- name: GetUserWithAddress :one
SELECT users.id, users.first_name, users.last_name, users.age, users.role, users.email, users.verified, users.phone, users.password_hash, users.created_at, users.updated_at, user_address.user_id, user_address.country, user_address.city, user_address.street_address, user_address.postal_code, user_address.created_at, user_address.updated_at
FROM users
LEFT JOIN user_address ON users.id = user_address.id
WHERE users.id = $1
`

type GetUserWithAddressRow struct {
	ID            uuid.UUID
	FirstName     string
	LastName      string
	Age           int32
	Role          string
	Email         string
	Verified      bool
	Phone         string
	PasswordHash  string
	CreatedAt     time.Time
	UpdatedAt     time.Time
	UserID        uuid.NullUUID
	Country       sql.NullString
	City          sql.NullString
	StreetAddress sql.NullString
	PostalCode    sql.NullString
	CreatedAt_2   sql.NullTime
	UpdatedAt_2   sql.NullTime
}

func (q *Queries) GetUserWithAddress(ctx context.Context, id uuid.UUID) (GetUserWithAddressRow, error) {
	row := q.db.QueryRowContext(ctx, getUserWithAddress, id)
	var i GetUserWithAddressRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Age,
		&i.Role,
		&i.Email,
		&i.Verified,
		&i.Phone,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Country,
		&i.City,
		&i.StreetAddress,
		&i.PostalCode,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return i, err
}

const resetAddress = `-- name: ResetAddress :exec
DELETE FROM user_address
`

func (q *Queries) ResetAddress(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetAddress)
	return err
}

const updateAddress = `-- name: UpdateAddress :one
UPDATE user_address
SET
    country = $1,
    city = $2,
    street_address = $3,
    postal_code = $4,
    updated_at = NOW()
WHERE user_id = $5
RETURNING user_id, country, city, street_address, postal_code, created_at, updated_at
`

type UpdateAddressParams struct {
	Country       string
	City          string
	StreetAddress string
	PostalCode    sql.NullString
	UserID        uuid.UUID
}

func (q *Queries) UpdateAddress(ctx context.Context, arg UpdateAddressParams) (UserAddress, error) {
	row := q.db.QueryRowContext(ctx, updateAddress,
		arg.Country,
		arg.City,
		arg.StreetAddress,
		arg.PostalCode,
		arg.UserID,
	)
	var i UserAddress
	err := row.Scan(
		&i.UserID,
		&i.Country,
		&i.City,
		&i.StreetAddress,
		&i.PostalCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
