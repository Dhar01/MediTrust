// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: address.sql

package userDB

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkAddressExist = `-- name: CheckAddressExist :one
SELECT EXISTS (SELECT 1 FROM user_address WHERE user_id = $1)
`

func (q *Queries) CheckAddressExist(ctx context.Context, userID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkAddressExist, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createUserAddress = `-- name: CreateUserAddress :one
INSERT INTO user_address (
    user_id, country, city, street_address, postal_code, created_at, updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    NOW(),
    NOW()
)
RETURNING user_id, country, city, street_address, postal_code, created_at, updated_at
`

type CreateUserAddressParams struct {
	UserID        pgtype.UUID
	Country       string
	City          string
	StreetAddress string
	PostalCode    pgtype.Text
}

func (q *Queries) CreateUserAddress(ctx context.Context, arg CreateUserAddressParams) (UserAddress, error) {
	row := q.db.QueryRow(ctx, createUserAddress,
		arg.UserID,
		arg.Country,
		arg.City,
		arg.StreetAddress,
		arg.PostalCode,
	)
	var i UserAddress
	err := row.Scan(
		&i.UserID,
		&i.Country,
		&i.City,
		&i.StreetAddress,
		&i.PostalCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAddress = `-- name: GetAddress :one
SELECT user_id, country, city, street_address, postal_code, created_at, updated_at FROM user_address
WHERE user_id = $1
`

func (q *Queries) GetAddress(ctx context.Context, userID pgtype.UUID) (UserAddress, error) {
	row := q.db.QueryRow(ctx, getAddress, userID)
	var i UserAddress
	err := row.Scan(
		&i.UserID,
		&i.Country,
		&i.City,
		&i.StreetAddress,
		&i.PostalCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserWithAddress = `-- name: GetUserWithAddress :one
SELECT users.id, users.first_name, users.last_name, users.age, users.role, users.email, users.verified, users.phone, users.password_hash, users.created_at, users.updated_at, user_address.user_id, user_address.country, user_address.city, user_address.street_address, user_address.postal_code, user_address.created_at, user_address.updated_at
FROM users
LEFT JOIN user_address ON users.id = user_address.id
WHERE users.id = $1
`

type GetUserWithAddressRow struct {
	ID            pgtype.UUID
	FirstName     string
	LastName      string
	Age           int32
	Role          string
	Email         string
	Verified      bool
	Phone         string
	PasswordHash  string
	CreatedAt     pgtype.Timestamp
	UpdatedAt     pgtype.Timestamp
	UserID        pgtype.UUID
	Country       pgtype.Text
	City          pgtype.Text
	StreetAddress pgtype.Text
	PostalCode    pgtype.Text
	CreatedAt_2   pgtype.Timestamp
	UpdatedAt_2   pgtype.Timestamp
}

func (q *Queries) GetUserWithAddress(ctx context.Context, id pgtype.UUID) (GetUserWithAddressRow, error) {
	row := q.db.QueryRow(ctx, getUserWithAddress, id)
	var i GetUserWithAddressRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Age,
		&i.Role,
		&i.Email,
		&i.Verified,
		&i.Phone,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Country,
		&i.City,
		&i.StreetAddress,
		&i.PostalCode,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return i, err
}

const resetAddress = `-- name: ResetAddress :exec
DELETE FROM user_address
`

func (q *Queries) ResetAddress(ctx context.Context) error {
	_, err := q.db.Exec(ctx, resetAddress)
	return err
}

const updateAddress = `-- name: UpdateAddress :one
UPDATE user_address
SET
    country = $1,
    city = $2,
    street_address = $3,
    postal_code = $4,
    updated_at = NOW()
WHERE user_id = $5
RETURNING user_id, country, city, street_address, postal_code, created_at, updated_at
`

type UpdateAddressParams struct {
	Country       string
	City          string
	StreetAddress string
	PostalCode    pgtype.Text
	UserID        pgtype.UUID
}

func (q *Queries) UpdateAddress(ctx context.Context, arg UpdateAddressParams) (UserAddress, error) {
	row := q.db.QueryRow(ctx, updateAddress,
		arg.Country,
		arg.City,
		arg.StreetAddress,
		arg.PostalCode,
		arg.UserID,
	)
	var i UserAddress
	err := row.Scan(
		&i.UserID,
		&i.Country,
		&i.City,
		&i.StreetAddress,
		&i.PostalCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
